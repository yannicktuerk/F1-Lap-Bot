"""Domain entity representing an ideal lap with physics-based speed profile.

This module defines the IdealLap entity which encapsulates the theoretical
optimal lap generated by physics calculations. Used by Mathe-Coach to compute
time deltas and identify improvement areas when comparing actual driver laps.
"""

import numpy as np
from dataclasses import dataclass
from typing import List


@dataclass(frozen=True)
class IdealLap:
    """Immutable value object representing an ideal lap with speed profile.
    
    Contains the theoretical optimal speed, throttle, and brake inputs at each
    distance point around the track. Generated by IdealLapConstructor using
    physics-based calculations considering track curvature, elevation, and
    vehicle dynamics.
    
    Attributes:
        track_id (str): Track identifier from F1 25.
        ideal_speed (np.ndarray): Speed at each distance point (m/s).
        ideal_throttle (np.ndarray): Binary throttle input (0/1) at each point.
        ideal_brake (np.ndarray): Binary brake input (0/1) at each point.
        distance (np.ndarray): Distance array aligned with TrackProfile (meters).
        sector_times (List[float]): Ideal sector times [s1, s2, s3] in seconds.
        total_time (float): Total ideal lap time in seconds.
    
    Invariants:
        - All arrays must have the same length
        - ideal_speed must be non-negative
        - ideal_throttle and ideal_brake must be binary (0 or 1)
        - distance must be monotonically increasing
        - sector_times must contain exactly 3 positive values
        - total_time must be positive
        - total_time should equal sum of sector_times (within tolerance)
    """
    
    track_id: str
    ideal_speed: np.ndarray
    ideal_throttle: np.ndarray
    ideal_brake: np.ndarray
    distance: np.ndarray
    sector_times: List[float]
    total_time: float
    
    def __post_init__(self):
        """Validate IdealLap fields after initialization.
        
        Raises:
            ValueError: If any invariant is violated with descriptive error message.
        """
        # Check track_id is non-empty
        if not self.track_id or not isinstance(self.track_id, str):
            raise ValueError(
                f"track_id must be a non-empty string, got {self.track_id}"
            )
        
        # Check array types
        if not isinstance(self.ideal_speed, np.ndarray):
            raise ValueError(
                f"ideal_speed must be numpy array, got {type(self.ideal_speed)}"
            )
        if not isinstance(self.ideal_throttle, np.ndarray):
            raise ValueError(
                f"ideal_throttle must be numpy array, got {type(self.ideal_throttle)}"
            )
        if not isinstance(self.ideal_brake, np.ndarray):
            raise ValueError(
                f"ideal_brake must be numpy array, got {type(self.ideal_brake)}"
            )
        if not isinstance(self.distance, np.ndarray):
            raise ValueError(
                f"distance must be numpy array, got {type(self.distance)}"
            )
        
        # Check array lengths match
        n_points = len(self.distance)
        if len(self.ideal_speed) != n_points:
            raise ValueError(
                f"ideal_speed length {len(self.ideal_speed)} must match distance length {n_points}"
            )
        if len(self.ideal_throttle) != n_points:
            raise ValueError(
                f"ideal_throttle length {len(self.ideal_throttle)} must match distance length {n_points}"
            )
        if len(self.ideal_brake) != n_points:
            raise ValueError(
                f"ideal_brake length {len(self.ideal_brake)} must match distance length {n_points}"
            )
        
        # Check minimum array length
        if n_points < 10:
            raise ValueError(
                f"Arrays must contain at least 10 points, got {n_points}"
            )
        
        # Check ideal_speed is non-negative
        if np.any(self.ideal_speed < 0):
            raise ValueError(
                f"ideal_speed must be non-negative, found negative values"
            )
        
        # Check ideal_throttle is binary (0 or 1)
        if not np.all(np.isin(self.ideal_throttle, [0, 1])):
            raise ValueError(
                f"ideal_throttle must contain only 0 or 1 values"
            )
        
        # Check ideal_brake is binary (0 or 1)
        if not np.all(np.isin(self.ideal_brake, [0, 1])):
            raise ValueError(
                f"ideal_brake must contain only 0 or 1 values"
            )
        
        # Check distance is monotonically increasing
        if not np.all(np.diff(self.distance) > 0):
            raise ValueError(
                f"distance must be monotonically increasing"
            )
        
        # Check distance starts at or near zero
        if self.distance[0] < -1.0 or self.distance[0] > 100.0:
            raise ValueError(
                f"distance should start near 0, got {self.distance[0]}"
            )
        
        # Check sector_times
        if not isinstance(self.sector_times, list):
            raise ValueError(
                f"sector_times must be a list, got {type(self.sector_times)}"
            )
        if len(self.sector_times) != 3:
            raise ValueError(
                f"sector_times must contain exactly 3 values, got {len(self.sector_times)}"
            )
        for i, sector_time in enumerate(self.sector_times):
            if sector_time <= 0:
                raise ValueError(
                    f"sector_times[{i}] must be positive, got {sector_time}"
                )
        
        # Check total_time is positive
        if self.total_time <= 0:
            raise ValueError(
                f"total_time must be positive, got {self.total_time}"
            )
        
        # Check total_time matches sum of sector_times (within 1% tolerance)
        sector_sum = sum(self.sector_times)
        tolerance = 0.01 * sector_sum  # 1% tolerance
        if abs(self.total_time - sector_sum) > tolerance:
            raise ValueError(
                f"total_time {self.total_time} must equal sum of sector_times "
                f"{sector_sum} (within 1% tolerance)"
            )
    
    def get_speed_at(self, distance: float) -> float:
        """Interpolate ideal speed at given distance.
        
        Uses linear interpolation to estimate the ideal speed at any distance
        point, even if it doesn't exactly match a sampled distance point.
        
        Args:
            distance: Distance along lap in meters.
            
        Returns:
            Interpolated ideal speed in m/s.
            
        Raises:
            ValueError: If distance is outside the valid range.
        """
        if distance < self.distance[0] or distance > self.distance[-1]:
            raise ValueError(
                f"distance {distance} is outside valid range "
                f"[{self.distance[0]}, {self.distance[-1]}]"
            )
        
        return float(np.interp(distance, self.distance, self.ideal_speed))
    
    def get_time_loss_at(self, distance: float, actual_speed: float) -> float:
        """Compute instantaneous time loss at given distance.
        
        Calculates the time loss per meter traveled at a specific distance point
        by comparing actual speed to ideal speed. Positive value indicates the
        driver is slower than ideal.
        
        Formula: time_loss = (1/v_actual - 1/v_ideal) per meter
        
        Args:
            distance: Distance along lap in meters.
            actual_speed: Actual speed in m/s.
            
        Returns:
            Instantaneous time loss in seconds per meter.
            Zero if either speed is zero or negative.
            
        Raises:
            ValueError: If distance is outside valid range or actual_speed is negative.
        """
        if actual_speed < 0:
            raise ValueError(
                f"actual_speed must be non-negative, got {actual_speed}"
            )
        
        ideal_speed = self.get_speed_at(distance)
        
        # Avoid division by zero
        if ideal_speed > 0 and actual_speed > 0:
            return (1.0 / actual_speed - 1.0 / ideal_speed)
        return 0.0
    
    def compute_total_time_loss(self, actual_lap_samples: List) -> float:
        """Compute total time loss over entire lap.
        
        Sums the instantaneous time losses across all telemetry samples in the
        actual lap, weighted by the distance interval between samples.
        
        Args:
            actual_lap_samples: List of TelemetrySample objects from actual lap.
            
        Returns:
            Total time loss in seconds. Positive means actual lap is slower.
            
        Raises:
            ValueError: If actual_lap_samples is empty or contains invalid samples.
        """
        if not actual_lap_samples:
            raise ValueError("actual_lap_samples cannot be empty")
        
        total_loss = 0.0
        
        for i, sample in enumerate(actual_lap_samples):
            # Get sample distance and speed
            sample_distance = sample.lap_distance
            sample_speed = sample.speed / 3.6  # Convert km/h to m/s
            
            # Skip if distance is outside valid range
            if sample_distance < self.distance[0] or sample_distance > self.distance[-1]:
                continue
            
            # Calculate instantaneous time loss
            dt_loss = self.get_time_loss_at(sample_distance, sample_speed)
            
            # Estimate distance interval to next sample
            if i < len(actual_lap_samples) - 1:
                next_distance = actual_lap_samples[i + 1].lap_distance
                ds = max(0, next_distance - sample_distance)
            else:
                # For last sample, use average spacing
                if len(actual_lap_samples) > 1:
                    total_lap_distance = self.distance[-1] - self.distance[0]
                    ds = total_lap_distance / len(actual_lap_samples)
                else:
                    ds = 10.0  # Default 10 meters if only one sample
            
            # Accumulate weighted time loss
            total_loss += dt_loss * ds
        
        return total_loss
    
    def get_sample_count(self) -> int:
        """Get number of distance points in ideal lap profile.
        
        Returns:
            Number of sampled points in the ideal lap arrays.
        """
        return len(self.distance)
    
    def get_lap_length(self) -> float:
        """Get total lap length in meters.
        
        Returns:
            Distance from first to last point in meters.
        """
        return float(self.distance[-1] - self.distance[0])
