"""Main orchestration use case for the TT-Coach pipeline (Issue 16)."""
import asyncio
import time
import logging
from typing import Optional, List, Dict, Any
from dataclasses import dataclass

from src.domain.entities.telemetry_sample import PlayerTelemetrySample
from src.domain.entities.coaching_action import CoachingAction
from src.domain.services.turn_split_service import (
    TurnCatalog, PerTurnSplitCalculator, RewardService, Track, TurnSplit
)
from src.application.services.safety_ampel_service import SafetyAmpelService
from src.application.services.candidate_generator import CandidateGenerator
from src.application.services.safety_gate_resolver import SafetyGateResolver
from src.application.services.action_selector import ActionSelector
from src.application.services.utility_estimator import UtilityEstimatorService
from src.application.services.bandit_policy import BanditPolicy
from src.application.services.reviewer_service import ReviewerService
from src.application.services.message_builder import MessageBuilder
from src.domain.services.corner_ranker import CornerRanker
from src.infrastructure.config import ConfigurationService
from src.infrastructure.observability import (
    ObservabilityFacade, CoachingRecommendationLog, ReviewerResultLog
)
from src.infrastructure.performance import PerformanceOptimizer

logger = logging.getLogger(__name__)


@dataclass
class CoachingReport:
    """Complete coaching report generated by the pipeline."""
    session_uid: str
    lap_number: int
    actions: List[CoachingAction]
    generation_time_ms: float
    total_utility: float
    safety_violations: List[str]
    performance_deltas: Dict[int, float]  # turn_id -> delta
    metadata: Dict[str, Any]


@dataclass
class LapCompletionEvent:
    """Event triggered when a lap is completed."""
    session_uid: str
    lap_number: int
    track: Track
    samples: List[PlayerTelemetrySample]
    timestamp: float


class CoachingUseCase:
    """Main use case orchestrating the complete coaching pipeline."""
    
    def __init__(self,
                 config_service: ConfigurationService,
                 observability: ObservabilityFacade,
                 performance_optimizer: PerformanceOptimizer,
                 safety_ampel_service: SafetyAmpelService,
                 candidate_generator: CandidateGenerator,
                 safety_gate_resolver: SafetyGateResolver,
                 utility_estimator: UtilityEstimatorService,
                 bandit_policy: BanditPolicy,
                 reviewer_service: ReviewerService,
                 message_builder: MessageBuilder,
                 corner_ranker: CornerRanker,
                 turn_catalog: TurnCatalog,
                 split_calculator: PerTurnSplitCalculator,
                 reward_service: RewardService):
        """Initialize coaching use case with all dependencies."""
        self.config = config_service
        self.observability = observability
        self.performance = performance_optimizer
        self.safety_ampel = safety_ampel_service
        self.candidate_gen = candidate_generator
        self.safety_resolver = safety_gate_resolver
        self.utility_estimator = utility_estimator
        self.bandit = bandit_policy
        self.reviewer = reviewer_service
        self.message_builder = message_builder
        self.corner_ranker = corner_ranker
        self.turn_catalog = turn_catalog
        self.split_calculator = split_calculator
        self.reward_service = reward_service
        
        # Performance tracking
        self.max_delay_ms = self.config.get_performance_config().get('max_report_generation_ms', 150)
        
        # Recent laps for comparison
        self._recent_splits: Dict[str, List[TurnSplit]] = {}  # session_uid -> splits
    
    async def process_lap_completion(self, event: LapCompletionEvent) -> CoachingReport:
        """Process lap completion and generate coaching report within 150ms."""
        start_time = time.time()
        
        try:
            with self.performance.time_operation("coaching_pipeline") as timer:
                # Step 1: Calculate turn splits for reward computation
                current_splits = await self._calculate_turn_splits(event)
                
                # Step 2: Run turn ranking to identify improvement opportunities
                ranked_corners = await self._rank_corners(event)
                
                # Step 3: Generate coaching candidates
                candidates = await self._generate_candidates(ranked_corners, event)
                
                # Step 4: Apply safety gates and resolve conflicts
                safe_candidates = await self._apply_safety_gates(candidates, event)
                
                # Step 5: Estimate utility for each candidate
                candidates_with_utility = await self._estimate_utilities(safe_candidates, event)
                
                # Step 6: Select actions using bandit policy
                selected_actions = await self._select_actions(candidates_with_utility, event)
                
                # Step 7: Generate coaching messages
                actions_with_messages = await self._generate_messages(selected_actions, event)
                
                # Step 8: Track for reviewer evaluation
                await self._track_for_review(actions_with_messages, event)
                
                # Step 9: Update bandit with rewards from previous laps
                await self._update_bandit_rewards(current_splits, event)
                
                generation_time_ms = (time.time() - start_time) * 1000
                
                # Create coaching report
                report = CoachingReport(
                    session_uid=event.session_uid,
                    lap_number=event.lap_number,
                    actions=actions_with_messages,
                    generation_time_ms=generation_time_ms,
                    total_utility=sum(action.expected_utility for action in actions_with_messages),
                    safety_violations=self._get_safety_violations(event),
                    performance_deltas=self._calculate_performance_deltas(current_splits),
                    metadata={
                        'track': event.track.name,
                        'total_candidates': len(candidates),
                        'safe_candidates': len(safe_candidates),
                        'selected_actions': len(selected_actions)
                    }
                )
                
                # Record performance
                self.observability.record_performance_timing(generation_time_ms)
                
                # Store splits for next lap comparison
                self._recent_splits[event.session_uid] = current_splits
                
                return report
                
        except Exception as e:
            generation_time_ms = (time.time() - start_time) * 1000
            logger.error(f"Error in coaching pipeline: {e}")
            
            # Return empty report on error
            return CoachingReport(
                session_uid=event.session_uid,
                lap_number=event.lap_number,
                actions=[],
                generation_time_ms=generation_time_ms,
                total_utility=0.0,
                safety_violations=[str(e)],
                performance_deltas={},
                metadata={'error': str(e)}
            )
    
    async def _calculate_turn_splits(self, event: LapCompletionEvent) -> List[TurnSplit]:
        """Calculate per-turn splits for the completed lap."""
        # Check cache first
        cache_key = f"splits_{event.session_uid}_{event.lap_number}"
        cached = self.performance.cache.get(cache_key)
        if cached:
            return cached
        
        # Calculate splits
        splits = self.split_calculator.calculate_turn_splits(event.samples, event.track)
        
        # Update reference times
        self.split_calculator.update_reference_times(splits, event.track)
        
        # Cache result
        self.performance.cache.put(cache_key, splits, ttl=60.0)
        
        return splits
    
    async def _rank_corners(self, event: LapCompletionEvent) -> List[Dict[str, Any]]:
        """Rank corners by improvement potential."""
        # Use cached ranking if available
        cache_key = f"ranking_{event.track.name}_{hash(tuple(s.session_time for s in event.samples[:5]))}"
        cached = self.performance.cache.get(cache_key)
        if cached:
            return cached
        
        # Calculate ranking
        ranked = self.corner_ranker.rank_corners_by_impact(event.samples)
        
        # Cache result
        self.performance.cache.put(cache_key, ranked, ttl=120.0)
        
        return ranked
    
    async def _generate_candidates(self, ranked_corners: List[Dict[str, Any]], 
                                 event: LapCompletionEvent) -> List[CoachingAction]:
        """Generate coaching candidates for top corners."""
        candidates = []
        
        # Limit to top 3 corners for performance
        top_corners = ranked_corners[:3]
        
        for corner_data in top_corners:
            corner_candidates = self.candidate_gen.generate_candidates(
                corner_data, event.samples
            )
            candidates.extend(corner_candidates)
        
        return candidates
    
    async def _apply_safety_gates(self, candidates: List[CoachingAction],
                                event: LapCompletionEvent) -> List[CoachingAction]:
        """Apply safety gates and resolve conflicts."""
        # Get safety assessment
        safety_state = self.safety_ampel.assess_safety(event.samples)
        
        # Filter safe candidates
        safe_candidates = self.safety_resolver.resolve_safety_conflicts(
            candidates, safety_state
        )
        
        return safe_candidates
    
    async def _estimate_utilities(self, candidates: List[CoachingAction],
                                event: LapCompletionEvent) -> List[CoachingAction]:
        """Estimate utility for each candidate action."""
        for candidate in candidates:
            try:
                # Use circuit breaker for ML utility estimation
                utility, confidence = self.performance.circuit_breaker.call(
                    self.utility_estimator.estimate_utility,
                    candidate, event.samples
                )
                
                candidate.expected_utility = utility
                candidate.confidence = confidence
                
            except Exception as e:
                logger.warning(f"Utility estimation failed for {candidate.action_type}: {e}")
                # Use fallback heuristic
                candidate.expected_utility = 0.02  # 20ms default
                candidate.confidence = 0.3
        
        return candidates
    
    async def _select_actions(self, candidates: List[CoachingAction],
                            event: LapCompletionEvent) -> List[CoachingAction]:
        """Select actions using bandit policy."""
        selected = []
        
        # Group candidates by corner
        by_corner = {}
        for candidate in candidates:
            corner_id = candidate.corner_id
            if corner_id not in by_corner:
                by_corner[corner_id] = []
            by_corner[corner_id].append(candidate)
        
        # Select best action per corner using bandit
        for corner_id, corner_candidates in by_corner.items():
            if corner_candidates:
                selected_action = self.bandit.select_action(
                    corner_candidates, 
                    context={'lap': event.lap_number, 'track': event.track.name}
                )
                if selected_action:
                    selected.append(selected_action)
        
        return selected
    
    async def _generate_messages(self, actions: List[CoachingAction],
                               event: LapCompletionEvent) -> List[CoachingAction]:
        """Generate coaching messages for selected actions."""
        for action in actions:
            message = self.message_builder.build_message(action, event.samples)
            action.coaching_message = message
        
        return actions
    
    async def _track_for_review(self, actions: List[CoachingAction],
                              event: LapCompletionEvent) -> None:
        """Track actions for reviewer evaluation."""
        for action in actions:
            # Log recommendation
            log_entry = CoachingRecommendationLog(
                timestamp=time.time(),
                session_uid=event.session_uid,
                lap_number=event.lap_number,
                turn_id=action.corner_id,
                action_type=action.action_type,
                coaching_message=action.coaching_message,
                expected_utility=action.expected_utility,
                confidence=action.confidence,
                safety_ampel=action.safety_ampel,
                slip_conditions={},  # TODO: Add slip conditions
                bandit_arm=action.bandit_arm if hasattr(action, 'bandit_arm') else 'unknown',
                exploration=action.exploration if hasattr(action, 'exploration') else False,
                context={'track': event.track.name}
            )
            
            self.observability.log_and_track_recommendation(log_entry)
    
    async def _update_bandit_rewards(self, current_splits: List[TurnSplit],
                                   event: LapCompletionEvent) -> None:
        """Update bandit policy with rewards from turn improvements."""
        # Get previous splits for comparison
        previous_splits = self._recent_splits.get(event.session_uid, [])
        
        if not previous_splits:
            return
        
        # Calculate rewards for each turn
        for current_split in current_splits:
            reward = self.reward_service.compute_turn_reward(
                [current_split], previous_splits, current_split.turn_id
            )
            
            if reward != 0:
                # Update bandit with reward
                self.bandit.update_reward(
                    current_split.turn_id, 
                    reward,
                    context={'lap': event.lap_number}
                )
    
    def _get_safety_violations(self, event: LapCompletionEvent) -> List[str]:
        """Get safety violations from the lap."""
        violations = []
        
        # Check for high slip conditions using motion ex data
        for sample in event.samples:
            if hasattr(sample, 'motion_ex_info') and sample.motion_ex_info:
                # Check for excessive slip if slip data is available
                if hasattr(sample.motion_ex_info, 'wheel_slip') and sample.motion_ex_info.wheel_slip:
                    max_slip = max(sample.motion_ex_info.wheel_slip)
                    if max_slip > 0.9:
                        violations.append(f"High slip detected: {max_slip:.2f}")
        
        return violations
    
    def _calculate_performance_deltas(self, splits: List[TurnSplit]) -> Dict[int, float]:
        """Calculate performance deltas by turn."""
        return {split.turn_id: split.delta for split in splits}


class CoachingOrchestrator:
    """Main orchestrator coordinating the entire coaching system."""
    
    def __init__(self, coaching_use_case: CoachingUseCase):
        """Initialize orchestrator."""
        self.coaching_use_case = coaching_use_case
        self._event_queue: asyncio.Queue = asyncio.Queue()
        self._running = False
        self._tasks: List[asyncio.Task] = []
    
    async def start(self) -> None:
        """Start the coaching orchestrator."""
        if self._running:
            return
        
        self._running = True
        
        # Start event processing loop
        self._tasks.append(asyncio.create_task(self._process_events()))
        
        logger.info("Coaching orchestrator started")
    
    async def stop(self) -> None:
        """Stop the coaching orchestrator."""
        self._running = False
        
        # Cancel all tasks
        for task in self._tasks:
            task.cancel()
        
        # Wait for tasks to complete
        if self._tasks:
            await asyncio.gather(*self._tasks, return_exceptions=True)
        
        self._tasks.clear()
        logger.info("Coaching orchestrator stopped")
    
    async def submit_lap_completion(self, event: LapCompletionEvent) -> CoachingReport:
        """Submit lap completion event for processing."""
        # Process immediately for real-time requirements
        return await self.coaching_use_case.process_lap_completion(event)
    
    async def _process_events(self) -> None:
        """Main event processing loop."""
        while self._running:
            try:
                # Process events from queue
                event = await asyncio.wait_for(self._event_queue.get(), timeout=1.0)
                
                # Process lap completion
                if isinstance(event, LapCompletionEvent):
                    report = await self.coaching_use_case.process_lap_completion(event)
                    logger.info(f"Generated coaching report for lap {event.lap_number} "
                              f"in {report.generation_time_ms:.1f}ms")
                
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Error processing event: {e}")